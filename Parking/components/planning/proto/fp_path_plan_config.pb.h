// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planning/proto/fp_path_plan_config.proto

#ifndef PROTOBUF_INCLUDED_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto
#define PROTOBUF_INCLUDED_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto 

namespace protobuf_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto
namespace planning {
class FpPathPlanConfig;
class FpPathPlanConfigDefaultTypeInternal;
extern FpPathPlanConfigDefaultTypeInternal _FpPathPlanConfig_default_instance_;
class ParallelCostParam;
class ParallelCostParamDefaultTypeInternal;
extern ParallelCostParamDefaultTypeInternal _ParallelCostParam_default_instance_;
class ParallelSampleConfig;
class ParallelSampleConfigDefaultTypeInternal;
extern ParallelSampleConfigDefaultTypeInternal _ParallelSampleConfig_default_instance_;
}  // namespace planning
namespace google {
namespace protobuf {
template<> ::planning::FpPathPlanConfig* Arena::CreateMaybeMessage<::planning::FpPathPlanConfig>(Arena*);
template<> ::planning::ParallelCostParam* Arena::CreateMaybeMessage<::planning::ParallelCostParam>(Arena*);
template<> ::planning::ParallelSampleConfig* Arena::CreateMaybeMessage<::planning::ParallelSampleConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace planning {

// ===================================================================

class ParallelSampleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.ParallelSampleConfig) */ {
 public:
  ParallelSampleConfig();
  virtual ~ParallelSampleConfig();

  ParallelSampleConfig(const ParallelSampleConfig& from);

  inline ParallelSampleConfig& operator=(const ParallelSampleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParallelSampleConfig(ParallelSampleConfig&& from) noexcept
    : ParallelSampleConfig() {
    *this = ::std::move(from);
  }

  inline ParallelSampleConfig& operator=(ParallelSampleConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParallelSampleConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParallelSampleConfig* internal_default_instance() {
    return reinterpret_cast<const ParallelSampleConfig*>(
               &_ParallelSampleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ParallelSampleConfig* other);
  friend void swap(ParallelSampleConfig& a, ParallelSampleConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParallelSampleConfig* New() const final {
    return CreateMaybeMessage<ParallelSampleConfig>(NULL);
  }

  ParallelSampleConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ParallelSampleConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ParallelSampleConfig& from);
  void MergeFrom(const ParallelSampleConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParallelSampleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double max_sample_length = 2;
  void clear_max_sample_length();
  static const int kMaxSampleLengthFieldNumber = 2;
  double max_sample_length() const;
  void set_max_sample_length(double value);

  // double sample_interval = 3;
  void clear_sample_interval();
  static const int kSampleIntervalFieldNumber = 3;
  double sample_interval() const;
  void set_sample_interval(double value);

  // int32 sample_line_number = 1;
  void clear_sample_line_number();
  static const int kSampleLineNumberFieldNumber = 1;
  ::google::protobuf::int32 sample_line_number() const;
  void set_sample_line_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning.ParallelSampleConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double max_sample_length_;
  double sample_interval_;
  ::google::protobuf::int32 sample_line_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParallelCostParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.ParallelCostParam) */ {
 public:
  ParallelCostParam();
  virtual ~ParallelCostParam();

  ParallelCostParam(const ParallelCostParam& from);

  inline ParallelCostParam& operator=(const ParallelCostParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParallelCostParam(ParallelCostParam&& from) noexcept
    : ParallelCostParam() {
    *this = ::std::move(from);
  }

  inline ParallelCostParam& operator=(ParallelCostParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParallelCostParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParallelCostParam* internal_default_instance() {
    return reinterpret_cast<const ParallelCostParam*>(
               &_ParallelCostParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ParallelCostParam* other);
  friend void swap(ParallelCostParam& a, ParallelCostParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParallelCostParam* New() const final {
    return CreateMaybeMessage<ParallelCostParam>(NULL);
  }

  ParallelCostParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ParallelCostParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ParallelCostParam& from);
  void MergeFrom(const ParallelCostParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParallelCostParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double center_cost_weight = 1;
  void clear_center_cost_weight();
  static const int kCenterCostWeightFieldNumber = 1;
  double center_cost_weight() const;
  void set_center_cost_weight(double value);

  // double lateral_cost_weight = 2;
  void clear_lateral_cost_weight();
  static const int kLateralCostWeightFieldNumber = 2;
  double lateral_cost_weight() const;
  void set_lateral_cost_weight(double value);

  // double lateral_collision_cost_weight = 3;
  void clear_lateral_collision_cost_weight();
  static const int kLateralCollisionCostWeightFieldNumber = 3;
  double lateral_collision_cost_weight() const;
  void set_lateral_collision_cost_weight(double value);

  // double longitudinal_collision_cost_weight = 4;
  void clear_longitudinal_collision_cost_weight();
  static const int kLongitudinalCollisionCostWeightFieldNumber = 4;
  double longitudinal_collision_cost_weight() const;
  void set_longitudinal_collision_cost_weight(double value);

  // double smooth_cost_weight = 5;
  void clear_smooth_cost_weight();
  static const int kSmoothCostWeightFieldNumber = 5;
  double smooth_cost_weight() const;
  void set_smooth_cost_weight(double value);

  // double safety_cost_weight = 6;
  void clear_safety_cost_weight();
  static const int kSafetyCostWeightFieldNumber = 6;
  double safety_cost_weight() const;
  void set_safety_cost_weight(double value);

  // double lateral_collision_buffer = 7;
  void clear_lateral_collision_buffer();
  static const int kLateralCollisionBufferFieldNumber = 7;
  double lateral_collision_buffer() const;
  void set_lateral_collision_buffer(double value);

  // @@protoc_insertion_point(class_scope:planning.ParallelCostParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double center_cost_weight_;
  double lateral_cost_weight_;
  double lateral_collision_cost_weight_;
  double longitudinal_collision_cost_weight_;
  double smooth_cost_weight_;
  double safety_cost_weight_;
  double lateral_collision_buffer_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FpPathPlanConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning.FpPathPlanConfig) */ {
 public:
  FpPathPlanConfig();
  virtual ~FpPathPlanConfig();

  FpPathPlanConfig(const FpPathPlanConfig& from);

  inline FpPathPlanConfig& operator=(const FpPathPlanConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FpPathPlanConfig(FpPathPlanConfig&& from) noexcept
    : FpPathPlanConfig() {
    *this = ::std::move(from);
  }

  inline FpPathPlanConfig& operator=(FpPathPlanConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FpPathPlanConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FpPathPlanConfig* internal_default_instance() {
    return reinterpret_cast<const FpPathPlanConfig*>(
               &_FpPathPlanConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FpPathPlanConfig* other);
  friend void swap(FpPathPlanConfig& a, FpPathPlanConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FpPathPlanConfig* New() const final {
    return CreateMaybeMessage<FpPathPlanConfig>(NULL);
  }

  FpPathPlanConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FpPathPlanConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FpPathPlanConfig& from);
  void MergeFrom(const FpPathPlanConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FpPathPlanConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .planning.ParallelSampleConfig sample_config = 1;
  bool has_sample_config() const;
  void clear_sample_config();
  static const int kSampleConfigFieldNumber = 1;
  private:
  const ::planning::ParallelSampleConfig& _internal_sample_config() const;
  public:
  const ::planning::ParallelSampleConfig& sample_config() const;
  ::planning::ParallelSampleConfig* release_sample_config();
  ::planning::ParallelSampleConfig* mutable_sample_config();
  void set_allocated_sample_config(::planning::ParallelSampleConfig* sample_config);

  // .planning.ParallelCostParam cost_param = 2;
  bool has_cost_param() const;
  void clear_cost_param();
  static const int kCostParamFieldNumber = 2;
  private:
  const ::planning::ParallelCostParam& _internal_cost_param() const;
  public:
  const ::planning::ParallelCostParam& cost_param() const;
  ::planning::ParallelCostParam* release_cost_param();
  ::planning::ParallelCostParam* mutable_cost_param();
  void set_allocated_cost_param(::planning::ParallelCostParam* cost_param);

  // double preview_distance = 3;
  void clear_preview_distance();
  static const int kPreviewDistanceFieldNumber = 3;
  double preview_distance() const;
  void set_preview_distance(double value);

  // double elegant_distance = 6;
  void clear_elegant_distance();
  static const int kElegantDistanceFieldNumber = 6;
  double elegant_distance() const;
  void set_elegant_distance(double value);

  // bool only_use_stanley = 4;
  void clear_only_use_stanley();
  static const int kOnlyUseStanleyFieldNumber = 4;
  bool only_use_stanley() const;
  void set_only_use_stanley(bool value);

  // bool enable_steer_rate_limit = 5;
  void clear_enable_steer_rate_limit();
  static const int kEnableSteerRateLimitFieldNumber = 5;
  bool enable_steer_rate_limit() const;
  void set_enable_steer_rate_limit(bool value);

  // @@protoc_insertion_point(class_scope:planning.FpPathPlanConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::planning::ParallelSampleConfig* sample_config_;
  ::planning::ParallelCostParam* cost_param_;
  double preview_distance_;
  double elegant_distance_;
  bool only_use_stanley_;
  bool enable_steer_rate_limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ParallelSampleConfig

// int32 sample_line_number = 1;
inline void ParallelSampleConfig::clear_sample_line_number() {
  sample_line_number_ = 0;
}
inline ::google::protobuf::int32 ParallelSampleConfig::sample_line_number() const {
  // @@protoc_insertion_point(field_get:planning.ParallelSampleConfig.sample_line_number)
  return sample_line_number_;
}
inline void ParallelSampleConfig::set_sample_line_number(::google::protobuf::int32 value) {
  
  sample_line_number_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelSampleConfig.sample_line_number)
}

// double max_sample_length = 2;
inline void ParallelSampleConfig::clear_max_sample_length() {
  max_sample_length_ = 0;
}
inline double ParallelSampleConfig::max_sample_length() const {
  // @@protoc_insertion_point(field_get:planning.ParallelSampleConfig.max_sample_length)
  return max_sample_length_;
}
inline void ParallelSampleConfig::set_max_sample_length(double value) {
  
  max_sample_length_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelSampleConfig.max_sample_length)
}

// double sample_interval = 3;
inline void ParallelSampleConfig::clear_sample_interval() {
  sample_interval_ = 0;
}
inline double ParallelSampleConfig::sample_interval() const {
  // @@protoc_insertion_point(field_get:planning.ParallelSampleConfig.sample_interval)
  return sample_interval_;
}
inline void ParallelSampleConfig::set_sample_interval(double value) {
  
  sample_interval_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelSampleConfig.sample_interval)
}

// -------------------------------------------------------------------

// ParallelCostParam

// double center_cost_weight = 1;
inline void ParallelCostParam::clear_center_cost_weight() {
  center_cost_weight_ = 0;
}
inline double ParallelCostParam::center_cost_weight() const {
  // @@protoc_insertion_point(field_get:planning.ParallelCostParam.center_cost_weight)
  return center_cost_weight_;
}
inline void ParallelCostParam::set_center_cost_weight(double value) {
  
  center_cost_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelCostParam.center_cost_weight)
}

// double lateral_cost_weight = 2;
inline void ParallelCostParam::clear_lateral_cost_weight() {
  lateral_cost_weight_ = 0;
}
inline double ParallelCostParam::lateral_cost_weight() const {
  // @@protoc_insertion_point(field_get:planning.ParallelCostParam.lateral_cost_weight)
  return lateral_cost_weight_;
}
inline void ParallelCostParam::set_lateral_cost_weight(double value) {
  
  lateral_cost_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelCostParam.lateral_cost_weight)
}

// double lateral_collision_cost_weight = 3;
inline void ParallelCostParam::clear_lateral_collision_cost_weight() {
  lateral_collision_cost_weight_ = 0;
}
inline double ParallelCostParam::lateral_collision_cost_weight() const {
  // @@protoc_insertion_point(field_get:planning.ParallelCostParam.lateral_collision_cost_weight)
  return lateral_collision_cost_weight_;
}
inline void ParallelCostParam::set_lateral_collision_cost_weight(double value) {
  
  lateral_collision_cost_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelCostParam.lateral_collision_cost_weight)
}

// double longitudinal_collision_cost_weight = 4;
inline void ParallelCostParam::clear_longitudinal_collision_cost_weight() {
  longitudinal_collision_cost_weight_ = 0;
}
inline double ParallelCostParam::longitudinal_collision_cost_weight() const {
  // @@protoc_insertion_point(field_get:planning.ParallelCostParam.longitudinal_collision_cost_weight)
  return longitudinal_collision_cost_weight_;
}
inline void ParallelCostParam::set_longitudinal_collision_cost_weight(double value) {
  
  longitudinal_collision_cost_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelCostParam.longitudinal_collision_cost_weight)
}

// double smooth_cost_weight = 5;
inline void ParallelCostParam::clear_smooth_cost_weight() {
  smooth_cost_weight_ = 0;
}
inline double ParallelCostParam::smooth_cost_weight() const {
  // @@protoc_insertion_point(field_get:planning.ParallelCostParam.smooth_cost_weight)
  return smooth_cost_weight_;
}
inline void ParallelCostParam::set_smooth_cost_weight(double value) {
  
  smooth_cost_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelCostParam.smooth_cost_weight)
}

// double safety_cost_weight = 6;
inline void ParallelCostParam::clear_safety_cost_weight() {
  safety_cost_weight_ = 0;
}
inline double ParallelCostParam::safety_cost_weight() const {
  // @@protoc_insertion_point(field_get:planning.ParallelCostParam.safety_cost_weight)
  return safety_cost_weight_;
}
inline void ParallelCostParam::set_safety_cost_weight(double value) {
  
  safety_cost_weight_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelCostParam.safety_cost_weight)
}

// double lateral_collision_buffer = 7;
inline void ParallelCostParam::clear_lateral_collision_buffer() {
  lateral_collision_buffer_ = 0;
}
inline double ParallelCostParam::lateral_collision_buffer() const {
  // @@protoc_insertion_point(field_get:planning.ParallelCostParam.lateral_collision_buffer)
  return lateral_collision_buffer_;
}
inline void ParallelCostParam::set_lateral_collision_buffer(double value) {
  
  lateral_collision_buffer_ = value;
  // @@protoc_insertion_point(field_set:planning.ParallelCostParam.lateral_collision_buffer)
}

// -------------------------------------------------------------------

// FpPathPlanConfig

// .planning.ParallelSampleConfig sample_config = 1;
inline bool FpPathPlanConfig::has_sample_config() const {
  return this != internal_default_instance() && sample_config_ != NULL;
}
inline void FpPathPlanConfig::clear_sample_config() {
  if (GetArenaNoVirtual() == NULL && sample_config_ != NULL) {
    delete sample_config_;
  }
  sample_config_ = NULL;
}
inline const ::planning::ParallelSampleConfig& FpPathPlanConfig::_internal_sample_config() const {
  return *sample_config_;
}
inline const ::planning::ParallelSampleConfig& FpPathPlanConfig::sample_config() const {
  const ::planning::ParallelSampleConfig* p = sample_config_;
  // @@protoc_insertion_point(field_get:planning.FpPathPlanConfig.sample_config)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::ParallelSampleConfig*>(
      &::planning::_ParallelSampleConfig_default_instance_);
}
inline ::planning::ParallelSampleConfig* FpPathPlanConfig::release_sample_config() {
  // @@protoc_insertion_point(field_release:planning.FpPathPlanConfig.sample_config)
  
  ::planning::ParallelSampleConfig* temp = sample_config_;
  sample_config_ = NULL;
  return temp;
}
inline ::planning::ParallelSampleConfig* FpPathPlanConfig::mutable_sample_config() {
  
  if (sample_config_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::ParallelSampleConfig>(GetArenaNoVirtual());
    sample_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.FpPathPlanConfig.sample_config)
  return sample_config_;
}
inline void FpPathPlanConfig::set_allocated_sample_config(::planning::ParallelSampleConfig* sample_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sample_config_;
  }
  if (sample_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sample_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sample_config, submessage_arena);
    }
    
  } else {
    
  }
  sample_config_ = sample_config;
  // @@protoc_insertion_point(field_set_allocated:planning.FpPathPlanConfig.sample_config)
}

// .planning.ParallelCostParam cost_param = 2;
inline bool FpPathPlanConfig::has_cost_param() const {
  return this != internal_default_instance() && cost_param_ != NULL;
}
inline void FpPathPlanConfig::clear_cost_param() {
  if (GetArenaNoVirtual() == NULL && cost_param_ != NULL) {
    delete cost_param_;
  }
  cost_param_ = NULL;
}
inline const ::planning::ParallelCostParam& FpPathPlanConfig::_internal_cost_param() const {
  return *cost_param_;
}
inline const ::planning::ParallelCostParam& FpPathPlanConfig::cost_param() const {
  const ::planning::ParallelCostParam* p = cost_param_;
  // @@protoc_insertion_point(field_get:planning.FpPathPlanConfig.cost_param)
  return p != NULL ? *p : *reinterpret_cast<const ::planning::ParallelCostParam*>(
      &::planning::_ParallelCostParam_default_instance_);
}
inline ::planning::ParallelCostParam* FpPathPlanConfig::release_cost_param() {
  // @@protoc_insertion_point(field_release:planning.FpPathPlanConfig.cost_param)
  
  ::planning::ParallelCostParam* temp = cost_param_;
  cost_param_ = NULL;
  return temp;
}
inline ::planning::ParallelCostParam* FpPathPlanConfig::mutable_cost_param() {
  
  if (cost_param_ == NULL) {
    auto* p = CreateMaybeMessage<::planning::ParallelCostParam>(GetArenaNoVirtual());
    cost_param_ = p;
  }
  // @@protoc_insertion_point(field_mutable:planning.FpPathPlanConfig.cost_param)
  return cost_param_;
}
inline void FpPathPlanConfig::set_allocated_cost_param(::planning::ParallelCostParam* cost_param) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cost_param_;
  }
  if (cost_param) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cost_param = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cost_param, submessage_arena);
    }
    
  } else {
    
  }
  cost_param_ = cost_param;
  // @@protoc_insertion_point(field_set_allocated:planning.FpPathPlanConfig.cost_param)
}

// double preview_distance = 3;
inline void FpPathPlanConfig::clear_preview_distance() {
  preview_distance_ = 0;
}
inline double FpPathPlanConfig::preview_distance() const {
  // @@protoc_insertion_point(field_get:planning.FpPathPlanConfig.preview_distance)
  return preview_distance_;
}
inline void FpPathPlanConfig::set_preview_distance(double value) {
  
  preview_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.FpPathPlanConfig.preview_distance)
}

// bool only_use_stanley = 4;
inline void FpPathPlanConfig::clear_only_use_stanley() {
  only_use_stanley_ = false;
}
inline bool FpPathPlanConfig::only_use_stanley() const {
  // @@protoc_insertion_point(field_get:planning.FpPathPlanConfig.only_use_stanley)
  return only_use_stanley_;
}
inline void FpPathPlanConfig::set_only_use_stanley(bool value) {
  
  only_use_stanley_ = value;
  // @@protoc_insertion_point(field_set:planning.FpPathPlanConfig.only_use_stanley)
}

// bool enable_steer_rate_limit = 5;
inline void FpPathPlanConfig::clear_enable_steer_rate_limit() {
  enable_steer_rate_limit_ = false;
}
inline bool FpPathPlanConfig::enable_steer_rate_limit() const {
  // @@protoc_insertion_point(field_get:planning.FpPathPlanConfig.enable_steer_rate_limit)
  return enable_steer_rate_limit_;
}
inline void FpPathPlanConfig::set_enable_steer_rate_limit(bool value) {
  
  enable_steer_rate_limit_ = value;
  // @@protoc_insertion_point(field_set:planning.FpPathPlanConfig.enable_steer_rate_limit)
}

// double elegant_distance = 6;
inline void FpPathPlanConfig::clear_elegant_distance() {
  elegant_distance_ = 0;
}
inline double FpPathPlanConfig::elegant_distance() const {
  // @@protoc_insertion_point(field_get:planning.FpPathPlanConfig.elegant_distance)
  return elegant_distance_;
}
inline void FpPathPlanConfig::set_elegant_distance(double value) {
  
  elegant_distance_ = value;
  // @@protoc_insertion_point(field_set:planning.FpPathPlanConfig.elegant_distance)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_planning_2fproto_2ffp_5fpath_5fplan_5fconfig_2eproto
